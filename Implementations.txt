For the function that converts a java expression (user's annotations that represent pre/post conditions), there are two approaches.

1) Transform the AST tree
advant: easy to do the transformation, even for the complex operators; 
no need to worry that transformation of one symbol affects others.
e.g. from < to <Int 
and <= to <=Int may interfere one another if we transform via String's replacing method.

disadvant:
the output may have some unnecessary brackets;
need some efforts to create the AST tree for the output structure.

2) pattern matching and replacing
advantage: no extra brackets; no need to build AST
disadvant: see the advant part of the previous approach.

//////////////////////
perf eval for the method of expr transformation:
Time complexity: N is the size of input expr, and k is the number of operators.
transform via AST:  O(N * 1)
transform via String replaceAll : O(k * N)


//**************************
Can change simple name's id, i.e. for a java exp, we can rename the its vars to conform to k-vars' convention.
